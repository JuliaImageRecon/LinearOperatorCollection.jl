var documenterSearchIndex = {"docs":
[{"location":"generated/tutorials/weighting/#Weighting-Operator","page":"Weighting Operator","title":"Weighting Operator","text":"include(\"../../util.jl\") #hide\n\nThe weighting operator implements a diagonal matrix which multiplies a vector index-wise with given weights. Such an operator is also implemented within LinearOperator.jl, however here this operator has a dedicated type on which one can dispatch:\n\nweights = collect(range(0, 1, length = N*N))\nop = WeightingOp(weights)\ntypeof(op)\n\nOne can retrieve the weights from the operator\n\nop.weights == weights\n\nNote that we didn't need to specify the element type of the operator here. In this case the eltype was derived from the provided weights.\n\nweighted_image = reshape(op * vec(image), N, N);\nnothing #hide\n\nTo visualize our weighted image, we will again use CairoMakie:\n\nfig = Figure()\nplot_image(fig[1,1], image, title = \"Image\")\nplot_image(fig[1,2], weighted_image, title = \"Weighted Image\")\nresize_to_layout!(fig)\nfig\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"references/","page":"Reference","title":"Reference","text":"Modules = [LinearOperatorCollection, isdefined(Base, :getextension) ? Base.getextension(LinearOperatorCollection, :LinearOperatorFFTWExt) : LinearOperatorCollection.LinearOperatorFFTWExt, isdefined(Base, :getextension) ? Base.getextension(LinearOperatorCollection, :LinearOperatorNFFTWExt) : LinearOperatorCollection.LinearOperatorNFFTWExt, isdefined(Base, :getextension) ? Base.getextension(LinearOperatorCollection, :LinearOperatoRadonWExt) : LinearOperatorCollection.LinearOperatorRadonExt, isdefined(Base, :getextension) ? Base.getextension(LinearOperatorCollection, :LinearOperatorWaveletExt) : LinearOperatorCollection.LinearOperatorWaveletExt, ]","category":"section"},{"location":"references/#LinearOperatorCollection.SamplingOp","page":"Reference","title":"LinearOperatorCollection.SamplingOp","text":"SamplingOp(pattern::Array{Int}, shape::Tuple)\n\nbuilds a LinearOperator which only returns the vector elements at positions indicated by pattern.\n\nArguents\n\npattern::Array{Int} - indices to sample\nshape::Tuple        - size of the array to sample\n\n\n\n\n\n","category":"type"},{"location":"references/#LinearOperatorCollection.WeightingOp","page":"Reference","title":"LinearOperatorCollection.WeightingOp","text":"WeightingOp(::Type{T}; weights::Vector{T}, rep::Int=1) where T\n\ngenerates a LinearOperator which multiplies an input vector index-wise with weights\n\nArguments\n\nweights::Vector{T} - weights vector\nrep::Int=1         - number of sub-arrays that need to be multiplied with weights\n\n\n\n\n\n","category":"type"},{"location":"references/#LinearOperatorCollection.DiagOp","page":"Reference","title":"LinearOperatorCollection.DiagOp","text":"DiagOp(ops...; scheduler = DynamicScheduler())\nDiagOp(ops::Vector{...}; scheduler = DynamicScheduler())\nDiagOp(ops::NTuple{N,...}; scheduler = DynamicScheduler())\n\ncreate a bloc-diagonal operator out of the LinearOperators  or Arrays contained in ops. Provide a OhMyThreads.Scheduler to change multi-tasking behaviour of the operator. Defaults to parallel execution\n\n\n\n\n\n","category":"type"},{"location":"references/#LinearOperatorCollection.GradientOp","page":"Reference","title":"LinearOperatorCollection.GradientOp","text":"GradientOp(T::Type; shape::Tuple, dims=1:length(shape))\n\ndirectional gradient operator along the dimensions dims for an array of size shape.\n\nRequired Argument\n\nT                        - type of elements, .e.g. Float64 for ComplexF32\n\nRequired Keyword argument\n\nshape::NTuple{N,Int}     - shape of the array (e.g., image)\n\nOptional Keyword argument\n\ndims                     - dimension(s) along which the gradient is applied; default is 1:length(shape)\n\n\n\n\n\n","category":"type"},{"location":"references/#LinearOperatorCollection.ProdOp","page":"Reference","title":"LinearOperatorCollection.ProdOp","text":"ProdOp(A,B)\n\ncomposition/product of two Operators. Computes (A * (B * x)). Differs with composition via * since it can handle normal operator and allows for specialisation on A and B.\n\n\n\n\n\n","category":"type"},{"location":"references/#LinearOperatorCollection.NormalOp","page":"Reference","title":"LinearOperatorCollection.NormalOp","text":"NormalOp(T::Type; parent, weights)\n\nLazy normal operator of parent with an optional weighting operator weights. Computes adjoint(parent) * weights * parent.\n\nRequired Argument\n\nT                        - type of elements, .e.g. Float64 for ComplexF32\n\nRequired Keyword argument\n\nparent                   - Base operator\n\nOptional Keyword argument\n\nweights                  - Optional weights for normal operator. Must already be of form weights = adjoint.(w) .* w\n\n\n\n\n\n","category":"type"},{"location":"references/#LinearOperatorCollection.normalOperator","page":"Reference","title":"LinearOperatorCollection.normalOperator","text":"normalOperator(prod::ProdOp{T, <:WeightingOp, matT}; kwargs...)\n\nFuses weights of ẀeightingOp by computing adjoint.(weights) .* weights\n\n\n\n\n\nnormalOperator(parent (, weights); kwargs...)\n\nConstructs a normal operator of the parent in an opinionated way, i.e. it tries to apply optimisations to the resulting operator.\n\n\n\n\n\n","category":"function"},{"location":"references/#LinearOperatorCollection.WaveletOp","page":"Reference","title":"LinearOperatorCollection.WaveletOp","text":"WaveletOp(shape, wt=wavelet(WT.db2))\n\nreturns a ẀaveletOp <: AbstractLinearOperator, which performs a Wavelet transform on a given input array.\n\nArguments\n\nshape                 - size of the Array to transform\n(wt=wavelet(WT.db2))  - Wavelet to apply\n\n\n\n\n\n","category":"type"},{"location":"references/#LinearOperatorCollection.RadonOp","page":"Reference","title":"LinearOperatorCollection.RadonOp","text":"RadonOp(::Type{T}; shape::NTuple{N, Int}, angles, geometry = RadonParallelCircle(shape[1], -(shape[1]-1)÷2:(shape[1]-1)÷2), μ = nothing, S = Vector{T}) where {T, N}\n\nGenerates a RadonOp which evaluates the Radon transform operator and its adjoint (backprojection) for a given geometry and projection angles.\n\nArguments:\n\nT                       - element type for the operator (e.g., Float64, ComplexF32)\nshape::NTuple{N, Int}   - size of the image\nangles                  - array of projection angles\ngeometry                - Radon geometry descriptor (default: parallel beam circle)\nμ                       - optional attenuation map (for attenuated Radon transform)\nS                       - storage type for internal vectors (default: Vector{T})\n\n\n\n\n\n","category":"type"},{"location":"references/#LinearOperatorCollection.NFFTOp","page":"Reference","title":"LinearOperatorCollection.NFFTOp","text":"NFFTOpImpl(shape::Tuple, tr::Trajectory; kargs...)\nNFFTOpImpl(shape::Tuple, tr::AbstractMatrix; kargs...)\n\ngenerates a NFFTOpImpl which evaluates the MRI Fourier signal encoding operator using the NFFT.\n\nArguments:\n\nshape::NTuple{D,Int64}  - size of image to encode/reconstruct\nnodes=nothing         - Array containg the trajectory nodes\ntoeplitz=false        - \noversamplingFactor=1.25\nkernelSize=3\nprecompute = AbstractNFFTs.TENSOR Precompute flag for the NFFT backend\n(kargs)                 - additional keyword arguments for the NFFT plan, \n\n\n\n\n\n","category":"type"},{"location":"references/#LinearOperatorCollection.FFTOp","page":"Reference","title":"LinearOperatorCollection.FFTOp","text":"FFTOp(T::Type; shape::Tuple, shift=true, unitary=true)\n\nreturns an operator which performs an FFT on Arrays of type T\n\nArguments:\n\nT::Type       - type of the array to transform\nshape::Tuple  - size of the array to transform\n(shift=true)  - if true, fftshifts are performed\n(unitary=true)  - if true, FFT is normalized such that it is unitary\n(S = Vector{T}) - type of temporary vector, change to use on GPU\n(kwargs...) - keyword arguments given to fft plan\n\n\n\n\n\n","category":"type"},{"location":"references/#LinearOperatorCollection.DCTOp","page":"Reference","title":"LinearOperatorCollection.DCTOp","text":"DCTOpImpl(T::Type, shape::Tuple, dcttype=2)\n\nreturns a DCTOpImpl <: AbstractLinearOperator which performs a DCT on a given input array.\n\nArguments:\n\nT::Type       - type of the array to transform\nshape::Tuple  - size of the array to transform\ndcttype       - type of DCT (currently 2 and 4 are supported)\n\n\n\n\n\n","category":"type"},{"location":"references/#LinearOperatorCollection.DSTOp","page":"Reference","title":"LinearOperatorCollection.DSTOp","text":"DSTOp(T::Type, shape::Tuple)\n\nreturns a LinearOperator which performs a DST on a given input array.\n\nArguments:\n\nT::Type       - type of the array to transform\nshape::Tuple  - size of the array to transform\n\n\n\n\n\n","category":"type"},{"location":"generated/tutorials/diagonal/#Block-Diagonal-Operator","page":"Diagonal Operator","title":"Block Diagonal Operator","text":"include(\"../../util.jl\") #hide\n\nThis operator represents a block-diagonal matrix out of given operators. One can also provide a single-operator and a number of blocks. In that case the given operator is repeated for each block. In the case of stateful operators, one can supply a method for copying the operators.\n\nblocks = N\nops = [WeightingOp(fill(i % 2, N)) for i = 1:N]\ndop = DiagOp(ops)\ntypeof(dop)\n\nWe can retrieve the operators:\n\ntypeof(dop.ops)\n\nAnd visualize the result:\n\nfig = Figure()\nplot_image(fig[1,1], image, title = \"Image\")\nplot_image(fig[1,2], reshape(dop * vec(image), N, N), title = \"Block Weighted\")\nresize_to_layout!(fig)\nfig\n\nThe default operator is created with a DynamicScheduler from OhMyThreads.jl. This means it will execute the multiplication of its individual blocks in parallel. To supply a different scheduler do:\n\nusing OhMyThreads\nscheduler = SerialScheduler()\ndop_serial = DiagOp(ops, scheduler = scheduler)\ntypeof(dop_serial)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/tutorials/gradient/#Gradient-Operator","page":"Gradient Operator","title":"Gradient Operator","text":"include(\"../../util.jl\") #hide\n\nThis operator computes a direction gradient along one or more dimensions of an array:\n\ngop = GradientOp(eltype(image); shape = (N, N), dims = 1)\ngradients = reshape(gop * vec(image), :, N)\nfig = Figure()\nplot_image(fig[1,1], image, title = \"Image\")\nplot_image(fig[1,2], gradients[:, :], title = \"Gradient\", colormap = :vik)\nresize_to_layout!(fig)\nfig\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/howtos/gpu/#GPU-Acceleration","page":"Enable GPU Acceleration","title":"GPU Acceleration","text":"include(\"../../util.jl\") #hide\n\nGPU kernels generally require all their arguments to exist on the GPU. This is not ncessarily the case for matrix-free operators as provides LinearOperators or LinearOperatorCollection. In the case that a matrix free operator is solely a function call and contains no internal array state, the operator is GPU compatible as long as the method has a GPU compatible implementation.\n\nIf the operator has internal fields required for its computation, such as temporary arrays for intermediate values or indices, then it needs to move those to the GPU. Furthermore if the operator needs to create a new array in its execution, e.g. it is used in a non-inplace matrix-vector multiplication or it is combined with other operators, then the operator needs to specify a storage type. LinearOperatorCollection has several GPU compatible operators, where the storage type is given by setting a S parameter:\n\nusing CUDA # or AMDGPU, Metal, ...\nimage_gpu = cu(image)\n\nusing LinearOperatorCollection.LinearOperators\nimage_gpu = image #hide\nstorage = Complex.(similar(image_gpu, 0))\nfop = FFTOp(eltype(image_gpu), shape = (N, N), S = typeof(storage))\nLinearOperators.storage_type(fop) == typeof(storage)\n\nGPU operators can be used just like the other operators. Note however, that a GPU operator does not necessarily work with a CPU vector.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/tutorials/sampling/#Sampling","page":"Sampling","title":"Sampling","text":"include(\"../../util.jl\") #hide\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/howtos/custom/#Implement-Custom-Operators","page":"Implement Custom Operators","title":"Implement Custom Operators","text":"There are two different ways one can implement a custom LinearOperator. The first one is to directly implement an operator as a LinearOperator from LinearOperators.jl:\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/tutorials/fft/#Fourier-Operator","page":"FFT Operator","title":"Fourier Operator","text":"include(\"../../util.jl\") #hide\n\nThe Fourier operator and its related operators for the discrete cosine and sine transform are available whenever FFTW.jl is loaded together with LinearOperatorCollection:\n\nusing LinearOperatorCollection, FFTW\nfop = FFTOp(Complex{eltype(image)}, shape = (N, N))\ncop = DCTOp(eltype(image), shape = (N, N))\nsop = DSTOp(eltype(image), shape = (N, N))\nimage_frequencies = reshape(fop * vec(image), N, N)\nimage_cosine = reshape(cop * vec(image), N, N)\nimage_sine = reshape(sop * vec(image), N, N)\n\nfig = Figure()\nplot_image(fig[1,1], image, title = \"Image\")\nplot_image(fig[1,2], abs.(image_frequencies) .+ eps(), title = \"Frequency Domain\", colorscale = log10)\nplot_image(fig[1,3], image_cosine, title = \"Cosine\")\nplot_image(fig[1,4], image_sine, title = \"Sine\")\nresize_to_layout!(fig)\nfig\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/tutorials/radon/#Radon-Operator","page":"Radon Operator","title":"Radon Operator","text":"include(\"../../util.jl\") #hide\n\nThe Radon operator is available when loading RadonKA.jl and LinearOperatorCollection:\n\nusing RadonKA\nangles = collect(range(0, π, N))\nrop = RadonOp(eltype(image); angles, shape = size(image));\nsinogram = reshape(rop * vec(image), :, N)\nfig = Figure()\nplot_image(fig[1,1], image, title = \"Image\")\nplot_image(fig[1,2], sinogram, title = \"Sinogram\")\nplot_image(fig[1,3], reshape(adjoint(rop) * vec(sinogram), N, N), title = \"Backprojection\")\nresize_to_layout!(fig)\nfig\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/tutorials/nfft/","page":"-","title":"-","text":"include(\"../../util.jl\") #hide\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/tutorials/normal/#Normal-operator","page":"Normal Operator","title":"Normal operator","text":"include(\"../../util.jl\") #hide\n\nThis operator implements a lazy normal operator implementing:\n\nbeginequation\n  (mathbfA)^*mathbfA\nendequation\n\nfor some operator mathbfA:\n\nusing FFTW\nfop = op = FFTOp(ComplexF32, shape = (N, N))\nnop = NormalOp(eltype(fop), parent = fop)\nisapprox(nop * vec(image), vec(image))\n\nAnd we can again access our original operator:\n\ntypeof(nop.parent)\n\nLinearOperatorCollection also provides an opinionated normalOperator function which tries to optimize the resulting normal operator. As an example consider the normal operator of a weighted fourier operator:\n\nweights = Float32.(collect(range(0, 1, length = N*N)))\nwop = WeightingOp(weights)\npop = ProdOp(wop, fop)\nnop = normalOperator(pop)\ntypeof(nop.parent) == typeof(pop)\n\nNote that the parent was changed. This is because the normal operator was optimized by initially computing the weights:\n\nbeginequation\n  tildemathbfW = mathbfW^*mathbfW\nendequation\n\nand then applying the following each iteration:\n\nbeginequation\n  mathbfA^*tildemathbfWmathbfA\nendequation\n\nOther operators can define different optimization strategies for the normalOperator method.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/tutorials/wavelet/#Wavelet-Operator","page":"Wavelet Operator","title":"Wavelet Operator","text":"include(\"../../util.jl\") #hide\n\nThe wavelet operator is available when loading Wavelets.jl together with LinearOperatorCollection:\n\nusing Wavelets\nwop = WaveletOp(eltype(image), shape = (N, N))\nwavelet_image = reshape(wop * vec(image), N, N)\nfig = Figure()\nplot_image(fig[1,1], image, title = \"Image\")\nplot_image(fig[1,2], abs.(wavelet_image) .+ eps(), title = \"Wavelet Image\", colorscale = sqrt)\nresize_to_layout!(fig)\nfig\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/tutorials/overview/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"To begin, we first need to load LinearOperatorCollection:\n\nusing LinearOperatorCollection\n\nIf we require an operator which is implemented via a package extensions, we also need to include the package that implements the functionality of the operator:\n\nusing FFTW\n\nAs an introduction, we will construct a two dimensional FFT operator and apply it to an image. To construct an operator we can either call its constructor directly:\n\nN = 256\nop = FFTOp(ComplexF32, shape = (N, N))\ntypeof(op)\n\nOr we can use the factory method:\n\nop = createLinearOperator(FFTOp{ComplexF64}, shape = (N, N))\n\nWe will use a Shepp-logan phantom as an example image:\n\nusing ImagePhantoms, ImageGeoms\nimage = shepp_logan(N, SheppLoganToft())\nsize(image)\n\nSince our operators are only defined for matrix-vector products, we can't directly apply them to the two-dimensional image. We first have to reshape the image to a vector:\n\ny = op * vec(image);\nnothing #hide\n\nAfterwards we can reshape the result and visualize it with CairoMakie:\n\nimage_freq = reshape(y, N, N)\nusing CairoMakie\nfunction plot_image(figPos, img; title = \"\", width = 150, height = 150, colorscale = identity)\n  ax = CairoMakie.Axis(figPos[1, 1]; yreversed=true, title, width, height)\n  hidedecorations!(ax)\n  hm = heatmap!(ax, img, colorscale = colorscale)\n  Colorbar(figPos[1, 2], hm)\nend\nfig = Figure()\nplot_image(fig[1,1], image, title = \"Image\")\nplot_image(fig[1,2], abs.(image_freq), title = \"Frequency Domain\", colorscale = log10)\nresize_to_layout!(fig)\nfig\n\nTo perform the inverse Fourier transform we can simply use the adjoint of our operator:\n\nimage_inverse = reshape(adjoint(op) * y, N, N)\nplot_image(fig[1,3], real.(image_inverse), title = \"Image after Inverse\")\nresize_to_layout!(fig)\nfig\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/tutorials/product/#Product-Operator","page":"Product Operator","title":"Product Operator","text":"include(\"../../util.jl\") #hide\n\nThis operator describes the product or composition between two operators:\n\nweights = collect(range(0, 1, length = N*N))\nwop = WeightingOp(weights)\nfop = FFTOp(ComplexF64, shape = (N, N));\nnothing #hide\n\nA feature of LinearOperators.jl is that operator can be cheaply transposed, conjugated and multiplied and only in the case of a matrix-vector product the combined operation is evaluated.\n\ntmp_op = wop * fop\ntmp_freqs = tmp_op * vec(image)\n\nSimilar to the WeightingOp, the main difference with the product operator provided by LinearOperatorCollection is the dedicated type, which allows for code specialisation.\n\npop = ProdOp(wop, fop)\ntypeof(pop)\n\nand the ability to retrieve the components:\n\ntypeof(pop.A)\n\nand\n\ntypeof(pop.B)\n\nOtherwise they compute the same thing:\n\npop * vec(image) == tmp_op * vec(image)\n\nNote that a product operator is not thread-safe.\n\nWe can again visualize our result:\n\nweighted_frequencies = reshape(pop * vec(image), N, N)\nimage_inverse = reshape(adjoint(pop) * vec(weighted_frequencies), N, N)\nfig = Figure()\nplot_image(fig[1,1], image, title = \"Image\")\nplot_image(fig[1,2], abs.(weighted_frequencies) .+ eps(), title = \"Frequency Domain\", colorscale = log10)\nplot_image(fig[1,3], real.(image_inverse), title = \"Image after Inverse\")\nresize_to_layout!(fig)\nfig\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"#LinearOperatorCollection","page":"Home","title":"LinearOperatorCollection","text":"Collection of linear operators for multi-dimensional signal and imaging tasks","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"This package contains a collection of linear operators that are particularly useful for multi-dimensional signal and image processing tasks. Linear operators or linear maps behave like matrices in a matrix-vector product, but aren't necessarily matrices themselves. They can utilize more effective algorithms and can defer their computation until they are multiplied with a vector.\n\nAll operators provided by this package extend types and methods LinearOperators.jl. For example this package provides operators for the FFT (Fast Fourier Transform) and its non-equidistant variant (NFFT), the DCT (Discrete Cosine Transform), and the Wavelet transform. This package, however, does not implement these transformation itself but uses established libraries for them.\n\nLinearOperatorCollection's main purpose is provide a wrapper around low-level libraries like FFTW.jl and NFFT.jl, which allows using the transformations as linear operators, i.e., implementing Op * x, adjoint(Op) * x and the mul! based in-place variants of the former.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"Within Julia, use the package manager to install this package:\n\nusing Pkg\nPkg.add(\"LinearOperatorCollection\")\n\nThis will install LinearOperatorCollection and a subset of the available operators. To keep the load time of this package low, many operators are implemented using package extensions. For instance, in order to get the FFTOp, one needs to install not only LinearOperatorCollection but also FFTW and load both in a Julia sessiong:\n\nPkg.add(\"FFTW\")\nusing LinearOperatorCollection, FFTW\n\nSmall operators are implemented in LinearOperatorCollection directly.","category":"section"},{"location":"#License-/-Terms-of-Usage","page":"Home","title":"License / Terms of Usage","text":"The source code of this project is licensed under the MIT license. This implies that you are free to use, share, and adapt it. However, please give appropriate credit by citing the project.","category":"section"},{"location":"#Contact","page":"Home","title":"Contact","text":"If you have problems using the software, find mistakes, or have general questions please use the issue tracker to contact us.","category":"section"},{"location":"#Related-Packages","page":"Home","title":"Related Packages","text":"There exist many related packages which also implement efficient and/or lazy operators:\n\nLinearOperators.jl\nLinearMaps.jl\nLazyArrays.jl\nBlockArrays.jl\nKronecker.jl\n\nGenerally, it should be possible to combine operators and arrays from various packages.","category":"section"}]
}
