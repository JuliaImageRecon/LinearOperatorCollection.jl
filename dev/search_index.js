var documenterSearchIndex = {"docs":
[{"location":"generated/tutorials/weighting/#Weighting-Operator","page":"Weighting Operator","title":"Weighting Operator","text":"","category":"section"},{"location":"generated/tutorials/weighting/","page":"Weighting Operator","title":"Weighting Operator","text":"include(\"../../util.jl\") #hide","category":"page"},{"location":"generated/tutorials/weighting/","page":"Weighting Operator","title":"Weighting Operator","text":"The weighting operator implements a diagonal matrix which multiplies a vector index-wise with given weights. Such an operator is also implemented within LinearOperator.jl, however here this operator has a dedicated type on which one can dispatch:","category":"page"},{"location":"generated/tutorials/weighting/","page":"Weighting Operator","title":"Weighting Operator","text":"weights = collect(range(0, 1, length = N*N))\nop = WeightingOp(weights)\ntypeof(op)","category":"page"},{"location":"generated/tutorials/weighting/","page":"Weighting Operator","title":"Weighting Operator","text":"One can retrieve the weights from the operator","category":"page"},{"location":"generated/tutorials/weighting/","page":"Weighting Operator","title":"Weighting Operator","text":"op.weights == weights","category":"page"},{"location":"generated/tutorials/weighting/","page":"Weighting Operator","title":"Weighting Operator","text":"Note that we didn't need to specify the element type of the operator here. In this case the eltype was derived from the provided weights.","category":"page"},{"location":"generated/tutorials/weighting/","page":"Weighting Operator","title":"Weighting Operator","text":"weighted_image = reshape(op * vec(image), N, N);\nnothing #hide","category":"page"},{"location":"generated/tutorials/weighting/","page":"Weighting Operator","title":"Weighting Operator","text":"To visualize our weighted image, we will again use CairoMakie:","category":"page"},{"location":"generated/tutorials/weighting/","page":"Weighting Operator","title":"Weighting Operator","text":"fig = Figure()\nplot_image(fig[1,1], image, title = \"Image\")\nplot_image(fig[1,2], weighted_image, title = \"Weighted Image\")\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"generated/tutorials/weighting/","page":"Weighting Operator","title":"Weighting Operator","text":"","category":"page"},{"location":"generated/tutorials/weighting/","page":"Weighting Operator","title":"Weighting Operator","text":"This page was generated using Literate.jl.","category":"page"},{"location":"references/#LinearOperatorCollection.SamplingOp","page":"Reference","title":"LinearOperatorCollection.SamplingOp","text":"SamplingOp(pattern::Array{Int}, shape::Tuple)\n\nbuilds a LinearOperator which only returns the vector elements at positions indicated by pattern.\n\nArguents\n\npattern::Array{Int} - indices to sample\nshape::Tuple        - size of the array to sample\n\n\n\n\n\n","category":"type"},{"location":"references/#LinearOperatorCollection.WeightingOp","page":"Reference","title":"LinearOperatorCollection.WeightingOp","text":"WeightingOp(::Type{T}; weights::Vector{T}, rep::Int=1) where T\n\ngenerates a LinearOperator which multiplies an input vector index-wise with weights\n\nArguments\n\nweights::Vector{T} - weights vector\nrep::Int=1         - number of sub-arrays that need to be multiplied with weights\n\n\n\n\n\n","category":"type"},{"location":"references/#LinearOperatorCollection.DiagOp","page":"Reference","title":"LinearOperatorCollection.DiagOp","text":"DiagOp(ops...)\nDiagOp(ops::Vector{...})\nDiagOp(ops::NTuple{N,...})\n\ncreate a bloc-diagonal operator out of the LinearOperators  or Arrays contained in ops\n\n\n\n\n\n","category":"type"},{"location":"references/#LinearOperatorCollection.GradientOp","page":"Reference","title":"LinearOperatorCollection.GradientOp","text":"GradientOp(T::Type; shape::Tuple, dims=1:length(shape))\n\ndirectional gradient operator along the dimensions dims for an array of size shape.\n\nRequired Argument\n\nT                        - type of elements, .e.g. Float64 for ComplexF32\n\nRequired Keyword argument\n\nshape::NTuple{N,Int}     - shape of the array (e.g., image)\n\nOptional Keyword argument\n\ndims                     - dimension(s) along which the gradient is applied; default is 1:length(shape)\n\n\n\n\n\n","category":"type"},{"location":"references/#LinearOperatorCollection.ProdOp","page":"Reference","title":"LinearOperatorCollection.ProdOp","text":"ProdOp(A,B)\n\ncomposition/product of two Operators. Computes (A * (B * x)). Differs with composition via * since it can handle normal operator and allows for specialisation on A and B.\n\n\n\n\n\n","category":"type"},{"location":"references/#LinearOperatorCollection.NormalOp","page":"Reference","title":"LinearOperatorCollection.NormalOp","text":"NormalOp(T::Type; parent, weights)\n\nLazy normal operator of parent with an optional weighting operator weights. Computes adjoint(parent) * weights * parent.\n\nRequired Argument\n\nT                        - type of elements, .e.g. Float64 for ComplexF32\n\nRequired Keyword argument\n\nparent                   - Base operator\n\nOptional Keyword argument\n\nweights                  - Optional weights for normal operator. Must already be of form weights = adjoint.(w) .* w\n\n\n\n\n\n","category":"type"},{"location":"references/#LinearOperatorCollection.normalOperator","page":"Reference","title":"LinearOperatorCollection.normalOperator","text":"normalOperator(prod::ProdOp{T, <:WeightingOp, matT}; kwargs...)\n\nFuses weights of ẀeightingOp by computing adjoint.(weights) .* weights\n\n\n\n\n\nnormalOperator(parent (, weights); kwargs...)\n\nConstructs a normal operator of the parent in an opinionated way, i.e. it tries to apply optimisations to the resulting operator.\n\n\n\n\n\n","category":"function"},{"location":"references/#LinearOperatorCollection.WaveletOp","page":"Reference","title":"LinearOperatorCollection.WaveletOp","text":"WaveletOp(shape, wt=wavelet(WT.db2))\n\nreturns a ẀaveletOp <: AbstractLinearOperator, which performs a Wavelet transform on a given input array.\n\nArguments\n\nshape                 - size of the Array to transform\n(wt=wavelet(WT.db2))  - Wavelet to apply\n\n\n\n\n\n","category":"type"},{"location":"references/#LinearOperatorCollection.RadonOp","page":"Reference","title":"LinearOperatorCollection.RadonOp","text":"RadonOp(::Type{T}; shape::NTuple{N, Int}, angles, geometry = RadonParallelCircle(shape[1], -(shape[1]-1)÷2:(shape[1]-1)÷2), μ = nothing, S = Vector{T}) where {T, N}\n\nGenerates a RadonOp which evaluates the Radon transform operator and its adjoint (backprojection) for a given geometry and projection angles.\n\nArguments:\n\nT                       - element type for the operator (e.g., Float64, ComplexF32)\nshape::NTuple{N, Int}   - size of the image\nangles                  - array of projection angles\ngeometry                - Radon geometry descriptor (default: parallel beam circle)\nμ                       - optional attenuation map (for attenuated Radon transform)\nS                       - storage type for internal vectors (default: Vector{T})\n\n\n\n\n\n","category":"type"},{"location":"references/#LinearOperatorCollection.NFFTOp","page":"Reference","title":"LinearOperatorCollection.NFFTOp","text":"NFFTOpImpl(shape::Tuple, tr::Trajectory; kargs...)\nNFFTOpImpl(shape::Tuple, tr::AbstractMatrix; kargs...)\n\ngenerates a NFFTOpImpl which evaluates the MRI Fourier signal encoding operator using the NFFT.\n\nArguments:\n\nshape::NTuple{D,Int64}  - size of image to encode/reconstruct\nnodes=nothing         - Array containg the trajectory nodes\ntoeplitz=false        - \noversamplingFactor=1.25\nkernelSize=3\nprecompute = AbstractNFFTs.TENSOR Precompute flag for the NFFT backend\n(kargs)                 - additional keyword arguments for the NFFT plan, \n\n\n\n\n\n","category":"type"},{"location":"references/#LinearOperatorCollection.FFTOp","page":"Reference","title":"LinearOperatorCollection.FFTOp","text":"FFTOp(T::Type; shape::Tuple, shift=true, unitary=true)\n\nreturns an operator which performs an FFT on Arrays of type T\n\nArguments:\n\nT::Type       - type of the array to transform\nshape::Tuple  - size of the array to transform\n(shift=true)  - if true, fftshifts are performed\n(unitary=true)  - if true, FFT is normalized such that it is unitary\n(S = Vector{T}) - type of temporary vector, change to use on GPU\n(kwargs...) - keyword arguments given to fft plan\n\n\n\n\n\n","category":"type"},{"location":"references/#LinearOperatorCollection.DCTOp","page":"Reference","title":"LinearOperatorCollection.DCTOp","text":"DCTOpImpl(T::Type, shape::Tuple, dcttype=2)\n\nreturns a DCTOpImpl <: AbstractLinearOperator which performs a DCT on a given input array.\n\nArguments:\n\nT::Type       - type of the array to transform\nshape::Tuple  - size of the array to transform\ndcttype       - type of DCT (currently 2 and 4 are supported)\n\n\n\n\n\n","category":"type"},{"location":"references/#LinearOperatorCollection.DSTOp","page":"Reference","title":"LinearOperatorCollection.DSTOp","text":"DSTOp(T::Type, shape::Tuple)\n\nreturns a LinearOperator which performs a DST on a given input array.\n\nArguments:\n\nT::Type       - type of the array to transform\nshape::Tuple  - size of the array to transform\n\n\n\n\n\n","category":"type"},{"location":"references/","page":"Reference","title":"Reference","text":"Modules = [LinearOperatorCollection, isdefined(Base, :getextension) ? Base.getextension(LinearOperatorCollection, :LinearOperatorFFTWExt) : LinearOperatorCollection.LinearOperatorFFTWExt, isdefined(Base, :getextension) ? Base.getextension(LinearOperatorCollection, :LinearOperatorNFFTWExt) : LinearOperatorCollection.LinearOperatorNFFTWExt, isdefined(Base, :getextension) ? Base.getextension(LinearOperatorCollection, :LinearOperatoRadonWExt) : LinearOperatorCollection.LinearOperatorRadonExt, isdefined(Base, :getextension) ? Base.getextension(LinearOperatorCollection, :LinearOperatorWaveletExt) : LinearOperatorCollection.LinearOperatorWaveletExt, ]","category":"page"},{"location":"generated/tutorials/diagonal/#Block-Diagonal-Operator","page":"Diagonal Operator","title":"Block Diagonal Operator","text":"","category":"section"},{"location":"generated/tutorials/diagonal/","page":"Diagonal Operator","title":"Diagonal Operator","text":"include(\"../../util.jl\") #hide","category":"page"},{"location":"generated/tutorials/diagonal/","page":"Diagonal Operator","title":"Diagonal Operator","text":"This operator represents a block-diagonal matrix out of given operators. One can also provide a single-operator and a number of blocks. In that case the given operator is repeated for each block. In the case of stateful operators, one can supply a method for copying the operators.","category":"page"},{"location":"generated/tutorials/diagonal/","page":"Diagonal Operator","title":"Diagonal Operator","text":"blocks = N\nops = [WeightingOp(fill(i % 2, N)) for i = 1:N]\ndop = DiagOp(ops)\ntypeof(dop)","category":"page"},{"location":"generated/tutorials/diagonal/","page":"Diagonal Operator","title":"Diagonal Operator","text":"We can retrieve the operators:","category":"page"},{"location":"generated/tutorials/diagonal/","page":"Diagonal Operator","title":"Diagonal Operator","text":"typeof(dop.ops)","category":"page"},{"location":"generated/tutorials/diagonal/","page":"Diagonal Operator","title":"Diagonal Operator","text":"And visualize the result:","category":"page"},{"location":"generated/tutorials/diagonal/","page":"Diagonal Operator","title":"Diagonal Operator","text":"fig = Figure()\nplot_image(fig[1,1], image, title = \"Image\")\nplot_image(fig[1,2], reshape(dop * vec(image), N, N), title = \"Block Weighted\")\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"generated/tutorials/diagonal/","page":"Diagonal Operator","title":"Diagonal Operator","text":"","category":"page"},{"location":"generated/tutorials/diagonal/","page":"Diagonal Operator","title":"Diagonal Operator","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/gradient/#Gradient-Operator","page":"Gradient Operator","title":"Gradient Operator","text":"","category":"section"},{"location":"generated/tutorials/gradient/","page":"Gradient Operator","title":"Gradient Operator","text":"include(\"../../util.jl\") #hide","category":"page"},{"location":"generated/tutorials/gradient/","page":"Gradient Operator","title":"Gradient Operator","text":"This operator computes a direction gradient along one or more dimensions of an array:","category":"page"},{"location":"generated/tutorials/gradient/","page":"Gradient Operator","title":"Gradient Operator","text":"gop = GradientOp(eltype(image); shape = (N, N), dims = 1)\ngradients = reshape(gop * vec(image), :, N)\nfig = Figure()\nplot_image(fig[1,1], image, title = \"Image\")\nplot_image(fig[1,2], gradients[:, :], title = \"Gradient\", colormap = :vik)\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"generated/tutorials/gradient/","page":"Gradient Operator","title":"Gradient Operator","text":"","category":"page"},{"location":"generated/tutorials/gradient/","page":"Gradient Operator","title":"Gradient Operator","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/howtos/gpu/#GPU-Acceleration","page":"Enable GPU Acceleration","title":"GPU Acceleration","text":"","category":"section"},{"location":"generated/howtos/gpu/","page":"Enable GPU Acceleration","title":"Enable GPU Acceleration","text":"include(\"../../util.jl\") #hide","category":"page"},{"location":"generated/howtos/gpu/","page":"Enable GPU Acceleration","title":"Enable GPU Acceleration","text":"GPU kernels generally require all their arguments to exist on the GPU. This is not ncessarily the case for matrix-free operators as provides LinearOperators or LinearOperatorCollection. In the case that a matrix free operator is solely a function call and contains no internal array state, the operator is GPU compatible as long as the method has a GPU compatible implementation.","category":"page"},{"location":"generated/howtos/gpu/","page":"Enable GPU Acceleration","title":"Enable GPU Acceleration","text":"If the operator has internal fields required for its computation, such as temporary arrays for intermediate values or indices, then it needs to move those to the GPU. Furthermore if the operator needs to create a new array in its execution, e.g. it is used in a non-inplace matrix-vector multiplication or it is combined with other operators, then the operator needs to specify a storage type. LinearOperatorCollection has several GPU compatible operators, where the storage type is given by setting a S parameter:","category":"page"},{"location":"generated/howtos/gpu/","page":"Enable GPU Acceleration","title":"Enable GPU Acceleration","text":"using CUDA # or AMDGPU, Metal, ...\nimage_gpu = cu(image)","category":"page"},{"location":"generated/howtos/gpu/","page":"Enable GPU Acceleration","title":"Enable GPU Acceleration","text":"using LinearOperatorCollection.LinearOperators\nimage_gpu = image #hide\nstorage = Complex.(similar(image_gpu, 0))\nfop = FFTOp(eltype(image_gpu), shape = (N, N), S = typeof(storage))\nLinearOperators.storage_type(fop) == typeof(storage)","category":"page"},{"location":"generated/howtos/gpu/","page":"Enable GPU Acceleration","title":"Enable GPU Acceleration","text":"GPU operators can be used just like the other operators. Note however, that a GPU operator does not necessarily work with a CPU vector.","category":"page"},{"location":"generated/howtos/gpu/","page":"Enable GPU Acceleration","title":"Enable GPU Acceleration","text":"","category":"page"},{"location":"generated/howtos/gpu/","page":"Enable GPU Acceleration","title":"Enable GPU Acceleration","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/sampling/#Sampling","page":"Sampling","title":"Sampling","text":"","category":"section"},{"location":"generated/tutorials/sampling/","page":"Sampling","title":"Sampling","text":"include(\"../../util.jl\") #hide","category":"page"},{"location":"generated/tutorials/sampling/","page":"Sampling","title":"Sampling","text":"","category":"page"},{"location":"generated/tutorials/sampling/","page":"Sampling","title":"Sampling","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/howtos/custom/#Implement-Custom-Operators","page":"Implement Custom Operators","title":"Implement Custom Operators","text":"","category":"section"},{"location":"generated/howtos/custom/","page":"Implement Custom Operators","title":"Implement Custom Operators","text":"There are two different ways one can implement a custom LinearOperator. The first one is to directly implement an operator as a LinearOperator from LinearOperators.jl:","category":"page"},{"location":"generated/howtos/custom/","page":"Implement Custom Operators","title":"Implement Custom Operators","text":"","category":"page"},{"location":"generated/howtos/custom/","page":"Implement Custom Operators","title":"Implement Custom Operators","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/fft/#Fourier-Operator","page":"FFT Operator","title":"Fourier Operator","text":"","category":"section"},{"location":"generated/tutorials/fft/","page":"FFT Operator","title":"FFT Operator","text":"include(\"../../util.jl\") #hide","category":"page"},{"location":"generated/tutorials/fft/","page":"FFT Operator","title":"FFT Operator","text":"The Fourier operator and its related operators for the discrete cosine and sine transform are available whenever FFTW.jl is loaded together with LinearOperatorCollection:","category":"page"},{"location":"generated/tutorials/fft/","page":"FFT Operator","title":"FFT Operator","text":"using LinearOperatorCollection, FFTW\nfop = FFTOp(Complex{eltype(image)}, shape = (N, N))\ncop = DCTOp(eltype(image), shape = (N, N))\nsop = DSTOp(eltype(image), shape = (N, N))\nimage_frequencies = reshape(fop * vec(image), N, N)\nimage_cosine = reshape(cop * vec(image), N, N)\nimage_sine = reshape(sop * vec(image), N, N)\n\nfig = Figure()\nplot_image(fig[1,1], image, title = \"Image\")\nplot_image(fig[1,2], abs.(image_frequencies) .+ eps(), title = \"Frequency Domain\", colorscale = log10)\nplot_image(fig[1,3], image_cosine, title = \"Cosine\")\nplot_image(fig[1,4], image_sine, title = \"Sine\")\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"generated/tutorials/fft/","page":"FFT Operator","title":"FFT Operator","text":"","category":"page"},{"location":"generated/tutorials/fft/","page":"FFT Operator","title":"FFT Operator","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/radon/#Radon-Operator","page":"Radon Operator","title":"Radon Operator","text":"","category":"section"},{"location":"generated/tutorials/radon/","page":"Radon Operator","title":"Radon Operator","text":"include(\"../../util.jl\") #hide","category":"page"},{"location":"generated/tutorials/radon/","page":"Radon Operator","title":"Radon Operator","text":"The Radon operator is available when loading RadonKA.jl and LinearOperatorCollection:","category":"page"},{"location":"generated/tutorials/radon/","page":"Radon Operator","title":"Radon Operator","text":"using RadonKA\nangles = collect(range(0, π, N))\nrop = RadonOp(eltype(image); angles, shape = size(image));\nsinogram = reshape(rop * vec(image), :, N)\nfig = Figure()\nplot_image(fig[1,1], image, title = \"Image\")\nplot_image(fig[1,2], sinogram, title = \"Sinogram\")\nplot_image(fig[1,3], reshape(adjoint(rop) * vec(sinogram), N, N), title = \"Backprojection\")\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"generated/tutorials/radon/","page":"Radon Operator","title":"Radon Operator","text":"","category":"page"},{"location":"generated/tutorials/radon/","page":"Radon Operator","title":"Radon Operator","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/nfft/","page":"-","title":"-","text":"include(\"../../util.jl\") #hide","category":"page"},{"location":"generated/tutorials/nfft/","page":"-","title":"-","text":"","category":"page"},{"location":"generated/tutorials/nfft/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/normal/#Normal-operator","page":"Normal Operator","title":"Normal operator","text":"","category":"section"},{"location":"generated/tutorials/normal/","page":"Normal Operator","title":"Normal Operator","text":"include(\"../../util.jl\") #hide","category":"page"},{"location":"generated/tutorials/normal/","page":"Normal Operator","title":"Normal Operator","text":"This operator implements a lazy normal operator implementing:","category":"page"},{"location":"generated/tutorials/normal/","page":"Normal Operator","title":"Normal Operator","text":"beginequation\n  (mathbfA)^*mathbfA\nendequation","category":"page"},{"location":"generated/tutorials/normal/","page":"Normal Operator","title":"Normal Operator","text":"for some operator mathbfA:","category":"page"},{"location":"generated/tutorials/normal/","page":"Normal Operator","title":"Normal Operator","text":"using FFTW\nfop = op = FFTOp(ComplexF32, shape = (N, N))\nnop = NormalOp(eltype(fop), parent = fop)\nisapprox(nop * vec(image), vec(image))","category":"page"},{"location":"generated/tutorials/normal/","page":"Normal Operator","title":"Normal Operator","text":"And we can again access our original operator:","category":"page"},{"location":"generated/tutorials/normal/","page":"Normal Operator","title":"Normal Operator","text":"typeof(nop.parent)","category":"page"},{"location":"generated/tutorials/normal/","page":"Normal Operator","title":"Normal Operator","text":"LinearOperatorCollection also provides an opinionated normalOperator function which tries to optimize the resulting normal operator. As an example consider the normal operator of a weighted fourier operator:","category":"page"},{"location":"generated/tutorials/normal/","page":"Normal Operator","title":"Normal Operator","text":"weights = Float32.(collect(range(0, 1, length = N*N)))\nwop = WeightingOp(weights)\npop = ProdOp(wop, fop)\nnop = normalOperator(pop)\ntypeof(nop.parent) == typeof(pop)","category":"page"},{"location":"generated/tutorials/normal/","page":"Normal Operator","title":"Normal Operator","text":"Note that the parent was changed. This is because the normal operator was optimized by initially computing the weights:","category":"page"},{"location":"generated/tutorials/normal/","page":"Normal Operator","title":"Normal Operator","text":"beginequation\n  tildemathbfW = mathbfW^*mathbfW\nendequation","category":"page"},{"location":"generated/tutorials/normal/","page":"Normal Operator","title":"Normal Operator","text":"and then applying the following each iteration:","category":"page"},{"location":"generated/tutorials/normal/","page":"Normal Operator","title":"Normal Operator","text":"beginequation\n  mathbfA^*tildemathbfWmathbfA\nendequation","category":"page"},{"location":"generated/tutorials/normal/","page":"Normal Operator","title":"Normal Operator","text":"Other operators can define different optimization strategies for the normalOperator method.","category":"page"},{"location":"generated/tutorials/normal/","page":"Normal Operator","title":"Normal Operator","text":"","category":"page"},{"location":"generated/tutorials/normal/","page":"Normal Operator","title":"Normal Operator","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/wavelet/#Wavelet-Operator","page":"Wavelet Operator","title":"Wavelet Operator","text":"","category":"section"},{"location":"generated/tutorials/wavelet/","page":"Wavelet Operator","title":"Wavelet Operator","text":"include(\"../../util.jl\") #hide","category":"page"},{"location":"generated/tutorials/wavelet/","page":"Wavelet Operator","title":"Wavelet Operator","text":"The wavelet operator is available when loading Wavelets.jl together with LinearOperatorCollection:","category":"page"},{"location":"generated/tutorials/wavelet/","page":"Wavelet Operator","title":"Wavelet Operator","text":"using Wavelets\nwop = WaveletOp(eltype(image), shape = (N, N))\nwavelet_image = reshape(wop * vec(image), N, N)\nfig = Figure()\nplot_image(fig[1,1], image, title = \"Image\")\nplot_image(fig[1,2], abs.(wavelet_image) .+ eps(), title = \"Wavelet Image\", colorscale = sqrt)\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"generated/tutorials/wavelet/","page":"Wavelet Operator","title":"Wavelet Operator","text":"","category":"page"},{"location":"generated/tutorials/wavelet/","page":"Wavelet Operator","title":"Wavelet Operator","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/overview/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"To begin, we first need to load LinearOperatorCollection:","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"using LinearOperatorCollection","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"If we require an operator which is implemented via a package extensions, we also need to include the package that implements the functionality of the operator:","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"using FFTW","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"As an introduction, we will construct a two dimensional FFT operator and apply it to an image. To construct an operator we can either call its constructor directly:","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"N = 256\nop = FFTOp(ComplexF32, shape = (N, N))\ntypeof(op)","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"Or we can use the factory method:","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"op = createLinearOperator(FFTOp{ComplexF64}, shape = (N, N))","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"We will use a Shepp-logan phantom as an example image:","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"using ImagePhantoms, ImageGeoms\nimage = shepp_logan(N, SheppLoganToft())\nsize(image)","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"Since our operators are only defined for matrix-vector products, we can't directly apply them to the two-dimensional image. We first have to reshape the image to a vector:","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"y = op * vec(image);\nnothing #hide","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"Afterwards we can reshape the result and visualize it with CairoMakie:","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"image_freq = reshape(y, N, N)\nusing CairoMakie\nfunction plot_image(figPos, img; title = \"\", width = 150, height = 150, colorscale = identity)\n  ax = CairoMakie.Axis(figPos[1, 1]; yreversed=true, title, width, height)\n  hidedecorations!(ax)\n  hm = heatmap!(ax, img, colorscale = colorscale)\n  Colorbar(figPos[1, 2], hm)\nend\nfig = Figure()\nplot_image(fig[1,1], image, title = \"Image\")\nplot_image(fig[1,2], abs.(image_freq), title = \"Frequency Domain\", colorscale = log10)\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"To perform the inverse Fourier transform we can simply use the adjoint of our operator:","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"image_inverse = reshape(adjoint(op) * y, N, N)\nplot_image(fig[1,3], real.(image_inverse), title = \"Image after Inverse\")\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/product/#Product-Operator","page":"Product Operator","title":"Product Operator","text":"","category":"section"},{"location":"generated/tutorials/product/","page":"Product Operator","title":"Product Operator","text":"include(\"../../util.jl\") #hide","category":"page"},{"location":"generated/tutorials/product/","page":"Product Operator","title":"Product Operator","text":"This operator describes the product or composition between two operators:","category":"page"},{"location":"generated/tutorials/product/","page":"Product Operator","title":"Product Operator","text":"weights = collect(range(0, 1, length = N*N))\nwop = WeightingOp(weights)\nfop = FFTOp(ComplexF64, shape = (N, N));\nnothing #hide","category":"page"},{"location":"generated/tutorials/product/","page":"Product Operator","title":"Product Operator","text":"A feature of LinearOperators.jl is that operator can be cheaply transposed, conjugated and multiplied and only in the case of a matrix-vector product the combined operation is evaluated.","category":"page"},{"location":"generated/tutorials/product/","page":"Product Operator","title":"Product Operator","text":"tmp_op = wop * fop\ntmp_freqs = tmp_op * vec(image)","category":"page"},{"location":"generated/tutorials/product/","page":"Product Operator","title":"Product Operator","text":"Similar to the WeightingOp, the main difference with the product operator provided by LinearOperatorCollection is the dedicated type, which allows for code specialisation.","category":"page"},{"location":"generated/tutorials/product/","page":"Product Operator","title":"Product Operator","text":"pop = ProdOp(wop, fop)\ntypeof(pop)","category":"page"},{"location":"generated/tutorials/product/","page":"Product Operator","title":"Product Operator","text":"and the ability to retrieve the components:","category":"page"},{"location":"generated/tutorials/product/","page":"Product Operator","title":"Product Operator","text":"typeof(pop.A)","category":"page"},{"location":"generated/tutorials/product/","page":"Product Operator","title":"Product Operator","text":"and","category":"page"},{"location":"generated/tutorials/product/","page":"Product Operator","title":"Product Operator","text":"typeof(pop.B)","category":"page"},{"location":"generated/tutorials/product/","page":"Product Operator","title":"Product Operator","text":"Otherwise they compute the same thing:","category":"page"},{"location":"generated/tutorials/product/","page":"Product Operator","title":"Product Operator","text":"pop * vec(image) == tmp_op * vec(image)","category":"page"},{"location":"generated/tutorials/product/","page":"Product Operator","title":"Product Operator","text":"Note that a product operator is not thread-safe.","category":"page"},{"location":"generated/tutorials/product/","page":"Product Operator","title":"Product Operator","text":"We can again visualize our result:","category":"page"},{"location":"generated/tutorials/product/","page":"Product Operator","title":"Product Operator","text":"weighted_frequencies = reshape(pop * vec(image), N, N)\nimage_inverse = reshape(adjoint(pop) * vec(weighted_frequencies), N, N)\nfig = Figure()\nplot_image(fig[1,1], image, title = \"Image\")\nplot_image(fig[1,2], abs.(weighted_frequencies) .+ eps(), title = \"Frequency Domain\", colorscale = log10)\nplot_image(fig[1,3], real.(image_inverse), title = \"Image after Inverse\")\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"generated/tutorials/product/","page":"Product Operator","title":"Product Operator","text":"","category":"page"},{"location":"generated/tutorials/product/","page":"Product Operator","title":"Product Operator","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#LinearOperatorCollection","page":"Home","title":"LinearOperatorCollection","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Collection of linear operators for multi-dimensional signal and imaging tasks","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package contains a collection of linear operators that are particularly useful for multi-dimensional signal and image processing tasks. Linear operators or linear maps behave like matrices in a matrix-vector product, but aren't necessarily matrices themselves. They can utilize more effective algorithms and can defer their computation until they are multiplied with a vector.","category":"page"},{"location":"","page":"Home","title":"Home","text":"All operators provided by this package extend types and methods LinearOperators.jl. For example this package provides operators for the FFT (Fast Fourier Transform) and its non-equidistant variant (NFFT), the DCT (Discrete Cosine Transform), and the Wavelet transform. This package, however, does not implement these transformation itself but uses established libraries for them.","category":"page"},{"location":"","page":"Home","title":"Home","text":"LinearOperatorCollection's main purpose is provide a wrapper around low-level libraries like FFTW.jl and NFFT.jl, which allows using the transformations as linear operators, i.e., implementing Op * x, adjoint(Op) * x and the mul! based in-place variants of the former.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Within Julia, use the package manager to install this package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"LinearOperatorCollection\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will install LinearOperatorCollection and a subset of the available operators. To keep the load time of this package low, many operators are implemented using package extensions. For instance, in order to get the FFTOp, one needs to install not only LinearOperatorCollection but also FFTW and load both in a Julia sessiong:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pkg.add(\"FFTW\")\nusing LinearOperatorCollection, FFTW","category":"page"},{"location":"","page":"Home","title":"Home","text":"Small operators are implemented in LinearOperatorCollection directly.","category":"page"},{"location":"#License-/-Terms-of-Usage","page":"Home","title":"License / Terms of Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The source code of this project is licensed under the MIT license. This implies that you are free to use, share, and adapt it. However, please give appropriate credit by citing the project.","category":"page"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have problems using the software, find mistakes, or have general questions please use the issue tracker to contact us.","category":"page"},{"location":"#Related-Packages","page":"Home","title":"Related Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There exist many related packages which also implement efficient and/or lazy operators:","category":"page"},{"location":"","page":"Home","title":"Home","text":"LinearOperators.jl\nLinearMaps.jl\nLazyArrays.jl\nBlockArrays.jl\nKronecker.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Generally, it should be possible to combine operators and arrays from various packages.","category":"page"}]
}
